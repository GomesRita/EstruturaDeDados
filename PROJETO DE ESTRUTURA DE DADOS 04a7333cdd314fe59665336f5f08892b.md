# PROJETO DE ESTRUTURA DE DADOS

**SUM√ÄRIO**

**SOBRE ESTE TRABALHO**

**link para acessar o Notion:**

[https://www.notion.so/PROJETO-DE-ESTRUTURA-DE-DADOS-04a7333cdd314fe59665336f5f08892b?pvs=4](https://www.notion.so/PROJETO-DE-ESTRUTURA-DE-DADOS-04a7333cdd314fe59665336f5f08892b?pvs=21)

**Discentes:**

DEMETRIUS FERREIRA DOS SANTOS

JANINE ALVES DA SILVA

MARIA GABRIELI DE MOURA RODRIGUES

MARIA RITA DA SILVA GOMES

**Livros utilizados:**

**EDELWEISS, Nina; GALANTE, Renata.** *Estruturas de Dados: Volume 18*. S√£o Paulo: Grupo A - Bookman, 2009. 262 p.

**BHARGAVA, Aditya Y.** *Algoritmos: Teoria e Pr√°tica*. S√£o Paulo: Novatec Editora, 2018. 264 p. 

# Quest√£o 1

Leia os cap√≠tulos de pilhas, filas e listas encadeadas, em livros dispon√≠veis na
biblioteca do campus. Anote os pontos principais e as explica√ß√µes fornecidas
sobre Filas, Pilhas e Listas Encadeadas.

**Resposta:**

Baseando nos livros de *Estrutura de dados* e *Algoritmos Teoria e Pr√°tica* foram *encontradas as seguintes explica√ß√µes e caracter√≠sticas sobre estas estruturas:*

**Sobre Lista Encadeada:**

1. Aprsenta um ponteiro para o primeiro nodo da lista; permite o acesso √† lista;
2. Realiza o encadeamento dos nodos atrav√©s de um campo de elo (refer√™ncia);
3. Apresenta um indicador de final de lista: o √∫ltimo nodo deve implementar um valor nulo que indique ao algoritmo o final da lista.
4. Um nodo √© composto por um campo que cont√©m a informa√ß√£o e um segundo que cont√©m o elo, refer√™ncia do pr√≥ximo nodo.
5. Os elementos podem estar em qualquer lugar da mem√≥ria. Um item indica o endere√ßo do pr√≥ximo.

**Sobre Pilhas:**

1. O item √© inserido no topo da lista, quando voc√™ consulta a pilha visualiza somente o item do topo e ele √© removido.
2. S√£o listas que respeitam a regra LIFO (Last In, First Out), o primeiro nodo a ser retirado deve ser o √∫ltimo que fora inserido.
3. Das opera√ß√µes que podem ser executadas:Criar pilha, consultar, excluir, modificar primeiro nodo e destruir pilha.

**Sobre Filas:**

1. Somente podem ser acessados os nodos das extremidades. 
2. Segue a regra FIFO (First In, First Out), o primeiro nodo retirado deve ser o primeiro que foi inclu√≠do.
3. Opera√ß√µes permitidas: Criar uma fila, inserir um novo nodo no final, excluir nodo no in√≠cio, consultar ou modificar o nodo do in√≠cio, destruir fila

# Quest√£o 2

Escreva um resumo cr√≠tico de cada cap√≠tulo lido. O resumo deve incluir:
o Uma vis√£o geral dos conceitos apresentados.
o Exemplos pr√°ticos discutidos no cap√≠tulo.
o Sua opini√£o sobre a clareza e utilidade das explica√ß√µes fornecidas.

**Resposta:**

**Resumo do Livro**: "Estruturas de Dados e Algoritmos: Teoria e Pr√°tica" de Nina Edelweiss e Renata Galante
**Vis√£o Geral dos Conceitos Apresentados**

O livro oferece uma abordagem completa sobre estruturas de dados e algoritmos, abordando desde os fundamentos b√°sicos at√© t√©cnicas mais avan√ßadas. A obra √© dividida em cap√≠tulos que cobrem uma ampla gama de t√≥picos, incluindo listas, pilhas, filas, √°rvores e grafos, al√©m de t√©cnicas de an√°lise de algoritmos. A proposta √© fornecer uma compreens√£o tanto te√≥rica quanto pr√°tica, enfatizando como as estruturas de dados podem ser aplicadas para resolver problemas reais de maneira eficiente.
**Exemplos Pr√°ticos Discutidos no Cap√≠tulo1.** 

1. **Listas e Arrays:**    - A introdu√ß√£o cobre a implementa√ß√£o de listas encadeadas e arrays.   - Exemplos pr√°ticos incluem a cria√ß√£o de uma lista encadeada para gerenciar um conjunto din√¢mico de dados e o uso de arrays para armazenar dados em um formato cont√≠guo na mem√≥ria.
2. **Pilhas e Filas**    - O cap√≠tulo sobre pilhas e filas oferece exemplos como a implementa√ß√£o de uma pilha para gerenciar a recurs√£o em algoritmos e uma fila para gerenciar um sistema de atendimento por prioridade, por exemplo, em um sistema de impress√£o.
3. **√Årvores**:    - A discuss√£o inclui √°rvores bin√°rias e √°rvores balanceadas, como √°rvores AVL.   - Um exemplo pr√°tico √© a implementa√ß√£o de uma √°rvore AVL para realizar buscas e inser√ß√µes de dados de forma eficiente em um banco de dados.
4. **Grafos**:    - O livro explora a teoria e a aplica√ß√£o de grafos, incluindo algoritmos de busca como BFS e DFS.   - Exemplos pr√°ticos incluem a implementa√ß√£o de algoritmos de caminho m√≠nimo, como o de Dijkstra, para roteamento em redes.

**Opini√£o Sobre a Clareza e Utilidade das Explica√ß√µes**

As explica√ß√µes fornecidas no livro s√£o claras e bem estruturadas. As autoras t√™m um estilo did√°tico que facilita a compreens√£o dos conceitos, com a inclus√£o de diagramas e exemplos de c√≥digo que ilustram os t√≥picos abordados. A utilidade das explica√ß√µes √© destacada pela aplica√ß√£o pr√°tica dos conceitos e pela discuss√£o detalhada sobre a efici√™ncia e a escolha de algoritmos. O livro √© eficaz tanto para estudantes quanto para profissionais, oferecendo uma base s√≥lida e aplic√°vel para a implementa√ß√£o de estruturas de dados e algoritmos.

# Quest√£o 3

Compare os conceitos de Filas, Pilhas e Listas Encadeadas apresentados nos
diferentes livros. Identifique semelhan√ßas e diferen√ßas na abordagem dos autores.

**Resposta**:

Os livros escolhidos foram ‚ÄúEntendendo algoritmos‚Äù de Aditya Y. Bhargava e ‚ÄúEstrutura de dados‚Äù

de Nina Edelweiss e Renata Galante. Ambos os livros abordam e explicam muito bem os principais conceitos

de filas, pilhas e listas encadeadas. A principal semelhan√ßa entre elas est√° na forma como abordam o assunto,

os autores tentam ser bem did√°ticos com o uso de figuras ilustrativas exemplificando com acontecimentos do cotidiano.

No entanto, existe um contraste entre nos dois livros que os diferencia. O primeiro, escrito por Aditya Y. Bhargava se utiliza de uma

linguagem simples,intuitiva e didatica usando bastantes exemplos do dia a dia, enquanto o segundo livro, escrito por Nina Edelweiss e Renata Galante,

tende para uma escrita formal e prioriza termos t√©cnicos.

# Quest√£o 4

Descreva algumas das aplica√ß√µes pr√°ticas das estruturas de dados mencionadas
nos cap√≠tulos. Inclua exemplos que voc√™ achou mais interessantes ou
surpreendentes.

**Resposta:**

As aplica√ß√µes encontradas no livro Entendendo algoritmos - um guia ilustrado para programadores e outros curiosos foram arrays, listas encadeadas, nota√ß√£o big O, busca sequencial, busca bin√°ria, ordena√ß√£o, Quicksort e hashes.

No livro Estrutura de dados foram encontradas as seguintes aplica√ß√µes Listas lineares e suas generaliza√ß√µes: listas ordenadas, listas encadeadas e filas. Aplica√ß√µes de listas. √Årvores e suas generaliza√ß√µes: √°rvores bin√°rias, √°rvores de busca, √°rvores balanceadas (AVL), √°rvores B e B +.Aplica√ß√£o de √°rvores.

# Quest√£o 5

Formule tr√™s perguntas para reflex√£o sobre cada estrutura de dados, baseadas nos
cap√≠tulos lidos. As perguntas devem incentivar uma an√°lise mais profunda e cr√≠tica
dos conceitos.

**Resposta:**

**1.Qual √© a complexidade de tempo para acessar um elemento espec√≠fico em um array e por que isso √© poss√≠vel?**

Resposta: A complexidade de tempo para acessar um elemento espec√≠fico em um array √© ùëÇ ( 1 ) O(1), ou tempo constante. Isso √© poss√≠vel porque os arrays armazenam elementos em posi√ß√µes de mem√≥ria cont√≠guas, permitindo o acesso direto a qualquer posi√ß√£o usando seu √≠ndice.

**2.Quais s√£o as principais opera√ß√µes que podem ser realizadas em um array e suas respectivas complexidades de tempo?**

Resposta:

- Acesso: O(1)O(1)O(1)
- Inser√ß√£o: O(n)O(n)O(n) no pior caso (se a inser√ß√£o for feita no in√≠cio ou no meio do array, todos os elementos subsequentes precisam ser deslocados)
- Remo√ß√£o: O(n)O(n)O(n) no pior caso (se a remo√ß√£o for feita no in√≠cio ou no meio do array, todos os elementos subsequentes precisam ser deslocados)
- Busca: O(n)O(n)O(n) no pior caso (se for uma busca linear)

**3.Quais s√£o as vantagens e desvantagens de usar arrays em compara√ß√£o com outras estruturas de dados, como listas ligadas?**

Resposta:

- Vantagens:
    - Acesso r√°pido a elementos usando √≠ndices (O(1)O(1)O(1))
    - Estrutura de dados simples e direta
- Desvantagens:
    - Tamanho fixo (necess√°rio definir o tamanho no momento da cria√ß√£o)
    - Inser√ß√£o e remo√ß√£o de elementos s√£o custosas (O(n)O(n)O(n) no pior caso)
    - Uso ineficiente de mem√≥ria se o array for subutilizado

**1.Qual √© a principal vantagem de uma lista encadeada sobre um array em termos de inser√ß√£o e remo√ß√£o de elementos?**

resposta: Considere a necessidade de mover elementos em um array versus a modifica√ß√£o de ponteiros em uma lista encadeada.

**2.Como funciona a inser√ß√£o de um novo n√≥ no meio de uma lista encadeada? Quais s√£o os passos necess√°rios para garantir que a lista mantenha sua integridade?**

resposta: Pense nos ponteiros do n√≥ atual, do novo n√≥ e do n√≥ seguinte.

**3.Qual √© a complexidade de tempo para acessar um elemento espec√≠fico em uma lista encadeada e por que? Como isso se compara ao acesso em um array?**

resposta: Compare o acesso sequencial em uma lista encadeada com o acesso direto em um array.

**1.Quais s√£o alguns exemplos de aplica√ß√µes onde o uso de listas ligadas pode ser mais vantajoso do que arrays?**

resposta:„Ö§Pense em situa√ß√µes onde a inser√ß√£o e remo√ß√£o de elementos √© frequente e ocorre em v√°rias partes da lista, como em gerenciadores de mem√≥ria ou sistemas de gerenciamento de tarefas.

**2.Como as listas s√£o usadas na implementa√ß√£o de outras estruturas de dados, como pilhas e filas, e quais s√£o as vantagens dessas implementa√ß√µes?**

resposta:„Ö§Considere a efici√™ncia de opera√ß√µes como push, pop (em pilhas), enqueque e dequeue (em filas) quando implementadas usando listas.

**3.Explique como listas duplamente ligadas podem ser utilizadas para criar um navegador de hist√≥rico de p√°ginas web**.

resposta:„Ö§Pense em como o ponteiro para o pr√≥ximo e anterior em cada n√≥ facilita a navega√ß√£o para frente e para tr√°s entre p√°ginas visitadas.

**1.O que √© uma √°rvore bin√°ria e como ela difere de uma √°rvore bin√°ria de busca?**

Resposta: Uma √°rvore bin√°ria √© uma estrutura de dados onde cada n√≥ tem no m√°ximo dois filhos, chamados de filho esquerdo e filho direito. Uma √°rvore bin√°ria de busca (BST - Binary Search Tree) √© uma √°rvore bin√°ria com a propriedade adicional de que o valor do n√≥ esquerdo √© sempre menor do que o valor do n√≥ pai, e o valor do n√≥ direito √© sempre maior. Isso facilita opera√ß√µes como busca, inser√ß√£o e remo√ß√£o de elementos.

**2.Quais s√£o as principais vantagens das √°rvores AVL em compara√ß√£o com as √°rvores bin√°rias de busca simples?**

Resposta: As √°rvores AVL s√£o um tipo de √°rvore bin√°ria de busca auto-balanceada. As principais vantagens das √°rvores AVL s√£o que elas mant√™m a altura balanceada ap√≥s cada inser√ß√£o e remo√ß√£o, garantindo que as opera√ß√µes de busca, inser√ß√£o e remo√ß√£o possam ser realizadas em tempo O(log n). Isso contrasta com as √°rvores bin√°rias de busca simples, que podem se tornar desequilibradas e degenerar em listas ligadas, resultando em opera√ß√µes de tempo O(n) no pior caso.

**3.O que s√£o √°rvores B e quais s√£o suas aplica√ß√µes t√≠picas?**

Resposta: √Årvores B s√£o √°rvores auto-balanceadas de ordem maior que duas, usadas principalmente em sistemas de gerenciamento de bancos de dados e sistemas de arquivos. Elas s√£o generaliza√ß√µes das √°rvores bin√°rias e podem ter mais de dois filhos por n√≥. As √°rvores B s√£o eficientes para opera√ß√µes de leitura e grava√ß√£o em disco porque minimizam o n√∫mero de acessos ao disco. Isso as torna ideais para armazenar grandes volumes de dados que n√£o cabem na mem√≥ria principal.

# Quest√£o 6

Implemente uma fila de prioridade para simular um sistema de mensageria onde
mensagens s√£o enviadas e processadas em ordem de prioridade. Crie uma classe
MensageriaPrioridade com m√©todos para adicionar mensagens √† fila com
diferentes n√≠veis de prioridade e process√°-las de acordo com a prioridade. Simule
o envio de v√°rias mensagens e o processamento das mesmas, exibindo mensagens
no console para indicar o estado da fila e as a√ß√µes realizadas.

## Solu√ß√£o

```jsx
// MensageriaPrioridade.js

/**
 * Representa uma mensagem com prioridade.
 * @typedef {Object} Mensagem
 * @property {string} conteudo - O conte√∫do da mensagem.
 * @property {number} prioridade - A prioridade da mensagem.
 */

/**
 * Classe para gerenciar uma fila de mensagens com prioridade.
 */
class MensageriaPrioridade {
    constructor() {
      this.fila = [];
    }
  
    /**
     * Adiciona uma mensagem √† fila com uma prioridade espec√≠fica.
     * @param {string} conteudo - O conte√∫do da mensagem.
     * @param {number} prioridade - A prioridade da mensagem (n√∫mero maior indica maior prioridade).
     */
    adicionarMensagem(conteudo, prioridade) {
      const mensagem = { conteudo, prioridade };
      this.fila.push(mensagem);
      this.fila.sort((a, b) => b.prioridade - a.prioridade);
      console.log(`Mensagem adicionada: ${conteudo} com prioridade ${prioridade}`);
    }
  
    /**
     * Processa a pr√≥xima mensagem na fila, removendo-a.
     * @returns {Mensagem|null} A mensagem processada ou null se a fila estiver vazia.
     */
    processarMensagem() {
      if (this.fila.length === 0) {
        console.log('Nenhuma mensagem para processar.');
        return null;
      }
      const mensagem = this.fila.shift();
      console.log(`Processando mensagem: ${mensagem.conteudo}`);
      return mensagem;
    }
  
    /**
     * Retorna o estado atual da fila de mensagens.
     * @returns {Mensagem[]} A fila de mensagens.
     */
    estadoFila() {
      console.log('Estado atual da fila:', this.fila);
      return this.fila;
    }
  }
  
  module.exports = MensageriaPrioridade;
  
```

## Teste

```jsx
// MensageriaPrioridade.test.js

const MensageriaPrioridade = require('./MensageriaPrioridade');

test('Deve adicionar mensagens com diferentes prioridades e process√°-las na ordem correta', () => {
  const mensageria = new MensageriaPrioridade();

  mensageria.adicionarMensagem('Mensagem 1', 1);
  mensageria.adicionarMensagem('Mensagem 2', 3);
  mensageria.adicionarMensagem('Mensagem 3', 2);

  expect(mensageria.processarMensagem().conteudo).toBe('Mensagem 2');
  expect(mensageria.processarMensagem().conteudo).toBe('Mensagem 3');
  expect(mensageria.processarMensagem().conteudo).toBe('Mensagem 1');
  expect(mensageria.processarMensagem()).toBe(null);
});
```

# Quest√£o 7

Implemente uma fila que simule o atendimento de clientes em um banco, onde os
clientes s√£o atendidos por ordem de chegada, mas com prioridade para clientes

preferenciais (por exemplo, idosos, gr√°vidas). Crie uma classe FilaBancoPrioridade
com m√©todos para adicionar clientes √† fila com diferentes n√≠veis de prioridade e
atend√™-los. Simule a chegada de clientes e o atendimento dos mesmos, exibindo
mensagens no console para indicar o estado da fila e as a√ß√µes realizadas.

## Solu√ß√£o

```jsx
class filaDeBancoPrioridade {
    constructor (){
     this.filaPrioridade1 = []; //60+
     this.filaPrioridade2 = []; //gestante
     this.filaComum = [];
    }

    add (nome, prioridade = 0) {
        if (prioridade === 1 ){ //idoso
            this.filaPrioridade1.push(nome);
            console.log(`Cliente ${nome} chegou na fila priorit√°ria 1 (maior de 60 anos)`);
        }else if (prioridade === 2) { //gestante
            this.filaPrioridade2.push(nome);
            console.log(`Cliente ${nome} chegou na fila priorit√°ria 2 (gestante)`);
        }else{
            this.filaComum.push(nome);
            console.log (`Cliente ${nome} chegou na fila comum`)
        }
    }
    atenderCliente (){
        if (this.filaPrioridade1.length > 0){
            const atendendoCliente = this.filaPrioridade1.shift();
            console.log(`Atendendo cliente priorit√°rio 1 (Maior de 60 anos): ${atendendoCliente}`);
        } else if (this.filaPrioridade2.length > 0){
                const atendendoCliente = this.filaPrioridade2.shift();
                console.log(`Atendendo o(a) cliente priorit√°rio 2 (gestante): ${atendendoCliente}`);
            } else if(this.filaComum.length > 0) {
                const atendendoCliente = this.filaComum.shift();
                console.log (`Atendendo o(a) cliente: ${atendendoCliente}`)
                } else {
                    if (this.filaComum.length === 0)
                        console.log (`N√£o h√° cliente na fila.`);
                    }
     }

        listarFilas(){
            console.log(`Pessoas na fila Priorit√°ria 1 (Maior de 60 anos): ${this.filaPrioridade1.join(', ')}`);
            console.log(`Pessoas na fila Priorit√°ria 2 (Gestante): ${this.filaPrioridade2.join(', ')}`);
            console.log(`Pessoas na fila comum: ${this.filaComum.join(', ')}`);    
        }
    }
   

const filaDeBanco = new filaDeBancoPrioridade();

filaDeBanco.add('Jo√£o', 1);
filaDeBanco.add('Ana', 1);
filaDeBanco.add('Cl√°udia', 2);
filaDeBanco.add('Maria');
filaDeBanco.add('Pedro');

filaDeBanco.listarFilas();

filaDeBanco.atenderCliente();
filaDeBanco.atenderCliente();
filaDeBanco.atenderCliente();
filaDeBanco.atenderCliente();
filaDeBanco.atenderCliente();
filaDeBanco.atenderCliente();
```

## Teste

```jsx
const filaDeBancoPrioridade = require('./Q7.js');

describe('filaDeBancoPrioridade', () => {
  let fila;

  beforeEach(() => {
    fila = new filaDeBancoPrioridade();
  });

  test('deve adicionar clientes √†s filas corretas', () => {
    fila.add('Jo√£o', 1);
    fila.add('Ana', 1);
    fila.add('Cl√°udia', 2);
    fila.add('Maria');
    fila.add('Pedro');

    expect(fila.filaPrioridade1).toEqual(['Jo√£o', 'Ana']);
    expect(fila.filaPrioridade2).toEqual(['Cl√°udia']);
    expect(fila.filaComum).toEqual(['Maria', 'Pedro']);
  });

  test('deve atender clientes na ordem correta', () => {
    fila.add('Jo√£o', 1);
    fila.add('Ana', 1);
    fila.add('Cl√°udia', 2);
    fila.add('Maria');
    fila.add('Pedro');

    const consoleSpy = jest.spyOn(console, 'log');
    fila.atenderCliente();
    fila.atenderCliente();
    fila.atenderCliente();
    fila.atenderCliente();
    fila.atenderCliente();
    fila.atenderCliente();
    fila.atenderCliente();

    expect(consoleSpy).toHaveBeenCalledWith('Atendendo cliente priorit√°rio 1 (Maior de 60 anos): Jo√£o');
    expect(consoleSpy).toHaveBeenCalledWith('Atendendo cliente priorit√°rio 1 (Maior de 60 anos): Ana');
    expect(consoleSpy).toHaveBeenCalledWith('Atendendo o(a) cliente priorit√°rio 2 (gestante): Cl√°udia');
    expect(consoleSpy).toHaveBeenCalledWith('Atendendo o(a) cliente: Maria');
    expect(consoleSpy).toHaveBeenCalledWith('Atendendo o(a) cliente: Pedro');
    expect(consoleSpy).toHaveBeenCalledWith('N√£o h√° cliente na fila.');

    consoleSpy.mockRestore();
  });

  test('deve listar as filas corretamente', () => {
    fila.add('Jo√£o', 1);
    fila.add('Ana', 1);
    fila.add('Cl√°udia', 2);
    fila.add('Maria');
    fila.add('Pedro');

    const consoleSpy = jest.spyOn(console, 'log');
    fila.listarFilas();

    expect(consoleSpy).toHaveBeenCalledWith('Pessoas na fila Priorit√°ria 1 (Maior de 60 anos): Jo√£o, Ana');
    expect(consoleSpy).toHaveBeenCalledWith('Pessoas na fila Priorit√°ria 2 (Gestante): Cl√°udia');
    expect(consoleSpy).toHaveBeenCalledWith('Pessoas na fila comum: Maria, Pedro');

    consoleSpy.mockRestore();
  });
});

```

# Quest√£o 8

Escreva uma fun√ß√£o que use uma pilha para converter express√µes infixas (onde os
operadores est√£o entre os operandos) para nota√ß√£o p√≥s-fixa (onde os operadores
est√£o ap√≥s os operandos). A fun√ß√£o deve receber uma string representando a

express√£o infixa e retornar uma string representando a express√£o em nota√ß√£o p√≥s-
fixa. Utilize uma pilha para gerenciar os operadores e garantir a preced√™ncia

correta.
o Express√µes Infixas:
‚ñ™ Os operadores est√£o posicionados entre os operandos.
‚ñ™ Exemplo: a+b
o Express√µes P√≥s-Fixas (ou Nota√ß√£o Polonesa Reversa):
‚ñ™ Os operadores v√™m ap√≥s os operandos.
‚ñ™ Exemplo: ab+

## Solu√ß√£o

```jsx
/**
 * Converte uma express√£o infixa para nota√ß√£o p√≥s-fixa (nota√ß√£o polonesa reversa).
 * 
 * @param {string} expressao - A express√£o aritm√©tica em nota√ß√£o infixa, por exemplo, "(3 + 4) * 5 - 6 / 2".
 * @returns {string} A express√£o convertida para nota√ß√£o p√≥s-fixa.
 */
function infixaParaPosfixa(expressao) {
    let saida = [];
    let operadores = [];
    let precedencia = {
        '^': 4, // Exponencia√ß√£o (associatividade √† direita)
        '*': 3, // Multiplica√ß√£o
        '/': 3, // Divis√£o
        '%': 3, // M√≥dulo
        '+': 2, // Adi√ß√£o
        '-': 2, // Subtra√ß√£o
        '(': 1  // Par√™ntese de abertura
    };

    /**
     * Verifica se um caractere √© um operador aritm√©tico.
     * 
     * @param {string} c - O caractere a ser verificado.
     * @returns {boolean} Retorna verdadeiro se o caractere for um operador, falso caso contr√°rio.
     */
    function verificarOperador(c) {
        return ['+', '-', '*', '/', '%', '^'].includes(c);
    }

    /**
     * Obt√©m a preced√™ncia de um operador.
     * 
     * @param {string} op - O operador cujo valor de preced√™ncia ser√° retornado.
     * @returns {number} O valor de preced√™ncia do operador.
     */
    function obterPrecedencia(op) {
        return precedencia[op] || 0;
    }

    /**
     * Aplica operadores da pilha √† sa√≠da conforme a preced√™ncia.
     * 
     * @param {string} op - O operador a ser comparado com os operadores na pilha.
     */
    function aplicarOperadores(op) {
        while (operadores.length > 0 && (obterPrecedencia(operadores[operadores.length - 1]) > obterPrecedencia(op) || 
               (obterPrecedencia(operadores[operadores.length - 1]) === obterPrecedencia(op) && op !== '^'))) {
            saida.push(operadores.pop());
        }
    }
    /**
     * Processa cada caractere da express√£o infixa para converter em nota√ß√£o p√≥s-fixa.
     * 
     * Itera sobre cada caractere da express√£o:
     * - Se o caractere √© um d√≠gito, ele acumula os d√≠gitos subsequentes para formar um n√∫mero completo e o adiciona √† sa√≠da.
     * - Se o caractere √© um par√™ntese de abertura '(', ele √© empurrado para a pilha de operadores.
     * - Se o caractere √© um par√™ntese de fechamento ')', desempilha operadores da pilha e os adiciona √† sa√≠da at√© encontrar o par√™ntese de abertura correspondente, que √© ent√£o removido da pilha.
     * - Se o caractere √© um operador, aplica operadores da pilha de acordo com a preced√™ncia e empurra o operador atual para a pilha.
     * 
     * @param {string} expressao - A express√£o aritm√©tica em nota√ß√£o infixa a ser processada.
     */
    for (let i = 0; i < expressao.length; i++) {
        let c = expressao[i];

        if (/\d/.test(c)) {  // Se o caractere √© um n√∫mero
            let num = c;
            while (i + 1 < expressao.length && /\d/.test(expressao[i + 1])) {
                num += expressao[++i]; 
            }
            saida.push(num);
        } else if (c === '(') {  
            operadores.push(c);
        } else if (c === ')') {
            while (operadores.length > 0 && operadores[operadores.length - 1] !== '(') {
                saida.push(operadores.pop());
            }
            operadores.pop();
        } else if (verificarOperador(c)) {  
            aplicarOperadores(c); 
            operadores.push(c);
        }
    }
    /**
     * Desempilha todos os operadores restantes
     */
    while (operadores.length > 0) {
        saida.push(operadores.pop());
    }

    return saida.join(' ');
}

module.exports = infixaParaPosfixa;

let expressaoInfixa = "(3 + 4) * 5 - 6 / 2";
let expressaoPosfixa = infixaParaPosfixa(expressaoInfixa);
console.log("Express√£o P√≥s-fixa:", expressaoPosfixa);
```

## Teste

```jsx
const infixaParaPosfixa = require('./Q8.js');

describe('Fun√ß√£o infixaParaPosfixa', () => {

    test('deve converter a express√£o infixa "(3 + 4) * 5 - 6 / 2" para p√≥s-fixa', () => {
        const expressaoInfixa = "(3 + 4) * 5 - 6 / 2";
        const resultadoEsperado = "3 4 + 5 * 6 2 / -";
        expect(infixaParaPosfixa(expressaoInfixa)).toBe(resultadoEsperado);
    });

    test('deve converter a express√£o infixa "3 + 4 * 2 / (1 - 5) ^ 2 ^ 3" para p√≥s-fixa', () => {
        const expressaoInfixa = "3 + 4 * 2 / (1 - 5) ^ 2 ^ 3";
        const resultadoEsperado = "3 4 2 * 1 5 - 2 3 ^ ^ / +";
        expect(infixaParaPosfixa(expressaoInfixa)).toBe(resultadoEsperado);
    });

    test('deve converter a express√£o infixa "1 + 2" para p√≥s-fixa', () => {
        const expressaoInfixa = "1 + 2";
        const resultadoEsperado = "1 2 +";
        expect(infixaParaPosfixa(expressaoInfixa)).toBe(resultadoEsperado);
    });

    test('deve converter a express√£o infixa "(1 + 2) * (3 + 4)" para p√≥s-fixa', () => {
        const expressaoInfixa = "(1 + 2) * (3 + 4)";
        const resultadoEsperado = "1 2 + 3 4 + *";
        expect(infixaParaPosfixa(expressaoInfixa)).toBe(resultadoEsperado);
    });

    test('deve converter a express√£o infixa "42" para p√≥s-fixa', () => {
        const expressaoInfixa = "42";
        const resultadoEsperado = "42";
        expect(infixaParaPosfixa(expressaoInfixa)).toBe(resultadoEsperado);
    });

    test('deve converter a express√£o infixa "2 + 3 * 4" para p√≥s-fixa', () => {
        const expressaoInfixa = "2 + 3 * 4";
        const resultadoEsperado = "2 3 4 * +";
        expect(infixaParaPosfixa(expressaoInfixa)).toBe(resultadoEsperado);
    });

});

```

# Quest√£o 9

Utilize uma pilha para implementar uma solu√ß√£o que encontre o caminho em um
labirinto bidimensional. A fun√ß√£o deve receber uma matriz representando o
labirinto, onde 0 indica um caminho livre e 1 indica uma parede. A fun√ß√£o deve
retornar um array de coordenadas representando o caminho encontrado. Utilize
uma pilha para gerenciar o percurso e as decis√µes de retrocesso.

## Solu√ß√£o

```jsx

```

## Teste

```jsx

```

# Quest√£o 10

Implemente uma classe ListaEncadeada para representar uma lista encadeada
simples. A classe deve incluir m√©todos para adicionar elementos ao final da lista,
remover elementos do in√≠cio da lista, buscar elementos por valor e exibir todos os
elementos da lista. Al√©m disso, implemente m√©todos para inserir elementos em
posi√ß√µes espec√≠ficas e remover elementos por valor. Simule a adi√ß√£o, remo√ß√£o e
busca de v√°rios elementos, exibindo o estado da lista a cada opera√ß√£o.

## Solu√ß√£o

```jsx
// ListaEncadeada.js

/**
 * Classe que representa um n√≥ na lista encadeada.
 */
class Nodo {
    /**
     * @param {*} valor - O valor armazenado no n√≥.
     */
    constructor(valor) {
      this.valor = valor;
      this.proximo = null;
    }
  }
  
  /**
   * Classe para gerenciar uma lista encadeada simples.
   */
  class ListaEncadeada {
    constructor() {
      this.cabeca = null;
    }
  
    /**
     * Adiciona um elemento ao final da lista.
     * @param {*} valor - O valor a ser adicionado.
     */
    adicionar(valor) {
      const novoNodo = new Nodo(valor);
      if (!this.cabeca) {
        this.cabeca = novoNodo;
      } else {
        let atual = this.cabeca;
        while (atual.proximo) {
          atual = atual.proximo;
        }
        atual.proximo = novoNodo;
      }
      console.log(`Adicionado: ${valor}`);
    }
  
    /**
     * Remove o elemento do in√≠cio da lista.
     * @returns {*} O valor do elemento removido ou null se a lista estiver vazia.
     */
    removerInicio() {
      if (!this.cabeca) {
        console.log('A lista est√° vazia');
        return null;
      }
      const removido = this.cabeca.valor;
      this.cabeca = this.cabeca.proximo;
      console.log(`Removido do in√≠cio: ${removido}`);
      return removido;
    }
  
    /**
     * Busca um elemento por valor na lista.
     * @param {*} valor - O valor a ser buscado.
     * @returns {Nodo|null} O n√≥ com o valor buscado ou null se n√£o for encontrado.
     */
    buscar(valor) {
      let atual = this.cabeca;
      while (atual) {
        if (atual.valor === valor) {
          console.log(`Encontrado: ${valor}`);
          return atual;
        }
        atual = atual.proximo;
      }
      console.log(`N√£o encontrado: ${valor}`);
      return null;
    }
  
    /**
     * Exibe todos os elementos da lista.
     * @returns {void}
     */
    exibir() {
      let atual = this.cabeca;
      const elementos = [];
      while (atual) {
        elementos.push(atual.valor);
        atual = atual.proximo;
      }
      console.log('Elementos da lista:', elementos);
    }
  
    /**
     * Insere um elemento em uma posi√ß√£o espec√≠fica.
     * @param {*} valor - O valor a ser inserido.
     * @param {number} posicao - A posi√ß√£o onde o valor ser√° inserido.
     */
    inserirNaPosicao(valor, posicao) {
      const novoNodo = new Nodo(valor);
      if (posicao === 0) {
        novoNodo.proximo = this.cabeca;
        this.cabeca = novoNodo;
        console.log(`Inserido ${valor} na posi√ß√£o ${posicao}`);
        return;
      }
  
      let atual = this.cabeca;
      let anterior = null;
      let index = 0;
  
      while (atual && index < posicao) {
        anterior = atual;
        atual = atual.proximo;
        index++;
      }
  
      if (anterior) {
        novoNodo.proximo = atual;
        anterior.proximo = novoNodo;
        console.log(`Inserido ${valor} na posi√ß√£o ${posicao}`);
      } else {
        console.log(`Posi√ß√£o ${posicao} fora do alcance`);
      }
    }
  
    /**
     * Remove um elemento por valor na lista.
     * @param {*} valor - O valor a ser removido.
     * @returns {boolean} Verdadeiro se o elemento foi removido, falso caso contr√°rio.
     */
    removerPorValor(valor) {
      if (!this.cabeca) {
        console.log('A lista est√° vazia');
        return false;
      }
  
      if (this.cabeca.valor === valor) {
        this.cabeca = this.cabeca.proximo;
        console.log(`Removido: ${valor}`);
        return true;
      }
  
      let atual = this.cabeca;
      let anterior = null;
  
      while (atual && atual.valor !== valor) {
        anterior = atual;
        atual = atual.proximo;
      }
  
      if (atual) {
        anterior.proximo = atual.proximo;
        console.log(`Removido: ${valor}`);
        return true;
      }
  
      console.log(`N√£o encontrado: ${valor}`);
      return false;
    }
  }
  
  module.exports = ListaEncadeada;
  
```

## Teste

```jsx
// ListaEncadeada.test.js

const ListaEncadeada = require('./ListaEncadeada');

test('Deve adicionar elementos ao final da lista e exibir os elementos', () => {
  const lista = new ListaEncadeada();
  lista.adicionar(10);
  lista.adicionar(20);
  lista.adicionar(30);
  expect(lista.cabeca.valor).toBe(10);
  expect(lista.cabeca.proximo.valor).toBe(20);
  expect(lista.cabeca.proximo.proximo.valor).toBe(30);
});

test('Deve remover elementos do in√≠cio da lista', () => {
  const lista = new ListaEncadeada();
  lista.adicionar(10);
  lista.adicionar(20);
  lista.removerInicio();
  expect(lista.cabeca.valor).toBe(20);
  lista.removerInicio();
  expect(lista.cabeca).toBe(null);
});

test('Deve buscar elementos por valor na lista', () => {
  const lista = new ListaEncadeada();
  lista.adicionar(10);
  lista.adicionar(20);
  lista.adicionar(30);
  expect(lista.buscar(20).valor).toBe(20);
  expect(lista.buscar(40)).toBe(null);
});

test('Deve inserir elementos em posi√ß√µes espec√≠ficas', () => {
  const lista = new ListaEncadeada();
  lista.adicionar(10);
  lista.adicionar(30);
  lista.inserirNaPosicao(20, 1);
  expect(lista.cabeca.valor).toBe(10);
  expect(lista.cabeca.proximo.valor).toBe(20);
  expect(lista.cabeca.proximo.proximo.valor).toBe(30);
});

test('Deve remover elementos por valor', () => {
  const lista = new ListaEncadeada();
  lista.adicionar(10);
  lista.adicionar(20);
  lista.adicionar(30);
  lista.removerPorValor(20);
  expect(lista.buscar(20)).toBe(null);
  expect(lista.cabeca.valor).toBe(10);
  expect(lista.cabeca.proximo.valor).toBe(30);
});
```

# Quest√£o 11

Implemente uma classe ListaDuplamenteEncadeada para representar uma lista
encadeada duplamente ligada. A classe deve incluir m√©todos para adicionar e
remover elementos tanto do in√≠cio quanto do final da lista, buscar elementos por
valor, exibir todos os elementos da lista em ambas as dire√ß√µes (da cabe√ßa para a
cauda e vice-versa). Simule a adi√ß√£o, remo√ß√£o e busca de v√°rios elementos,
exibindo o estado da lista a cada opera√ß√£o.

## Solu√ß√£o

```jsx
/**
 * @class Classe objeto que representa o N√≥, contendo o valor, o endere√ßo do pr√≥ximo objeto e do objeto anterior.
 */
class No {
    constructor(valor) {
        this.valor = valor;
        this.proximo = null;
        this.anterior = null;
    }
}

class ListaDuplamenteEncadeada {
    constructor() {
        this.inicio = null;
        this.final = null;
        this.tamanho = 0;
    }

    adicionarInicio(valor) {
        let no = new No(valor);
        /**
         * @description 
         * if (this.tamanho === 0) - verifica se a lista est√° vazia
         * no.proximo - indica que o atual primeiro n√≥ agora ser√° o pr√≥ximo ap√≥s inserir o novo n√≥
         * this.inicio.anterior - recebe o novo n√≥ como o ANTERIOR ao atual primeiro n√≥
         * 
         * @param {this.tamanho++} this.tamanho - aumenta a lista em +1
         */
        if (this.tamanho === 0) {
            this.inicio = no;
            this.final = no;
        } else {
            no.proximo = this.inicio;
            this.inicio.anterior = no;
            this.inicio = no;
        }
        this.tamanho++;
    }
    /**
     * @description 
     * if (this.inicio === this.final) - se a lista tiver apenas 1 elemento atualiza inicio e final para null
     * this.inicio = this.inicio.proximo; - indica que inicio agora receber√° o PROXIMO objeto da lista
     * this.inicio.anterior = null; - apaga o 'endere√ßo' do objeto anterior do primeiro n√≥ da fila 
     * 
     * @param {this.tamanho--} this.tamanho - descresce 1 o tamanho da lista 
     */
    removerInicio() {
        if (this.inicio !== null) {
            if (this.inicio === this.final) {
                this.inicio = null;
                this.final = null;
            } else {
                this.inicio = this.inicio.proximo;
                this.inicio.anterior = null;
            }
            this.tamanho--;
        } else {
            console.log("A lista est√° vazia");
        }
    }

    /**
     * @description 
     * se a lista estiver vazia o novo n√≥ ser√° o inicio e o final
     * se n√£o, o novo n√≥ recebe o atual this.final como anterior.
     *  > o atual this.final recebe o n√≥ como pr√≥ximo
     *  > o novo n√≥ √© adicionado ao final
     */

    adicionarFinal(valor) {
        let no = new No(valor);

        if (this.tamanho === 0) {
            this.inicio = no;
            this.final = no;
        } else {
            no.anterior = this.final;
            this.final.proximo = no;
            this.final = no;
        }
        this.tamanho++;
    }

    /**
     * @description
     * se a lista s√≥ possuir um elemento this.inicio e this.final deve
     * receber null indicando que a lista est√° vazia;
     * se n√£o this.final recebe o valor do objeto anterior
     * a ele e atualiza o valor PROXIMO para null;
     *  @param {this.tamanho--} this.tamanho - descresce 1 o tamanho da lista
     */
    removerFinal() {
        if (this.final !== null) {
            if (this.inicio === this.final) {
                this.inicio = null;
                this.final = null;
            } else {
                this.final = this.final.anterior;
                this.final.proximo = null;
            }
            this.tamanho--;
        } else {
            console.log('A lista est√° vazia');
        }
    }
    /**
     * @description
     * recebe o valor de um n√≥ e busca ele percorrendo a lista do come√ßo ao final;
     * @param {let atual} atual - recebe o primeiro objeto da lista
     * @param {valor} valor - objeto procurado na lista
     */
    buscarElementos(valor) {
        let atual = this.inicio;
        while (atual !== null) {
            if (atual.valor === valor) {
                console.log("\nN√≥ encontrado: " + atual.valor);
                return true;
            }
            atual = atual.proximo;
        }
        console.log('N√≥ n√£o encontrado');
        return false;
    }
    /**
     * @description 
     * percorre a lista retornando do primeiro ao √∫ltimo elemento
     * @param {const anteriorValor} anteriorValor -  verifica se o valor contido no n√≥ √© v√°lido para ser retornado
     * se n√£o atribui null, evitando erros.
     * @param {const proximoValor} proximoValor - verifica se o valor contido no n√≥ √© v√°lido para ser retornado
     * se n√£o atribui null, evitando erros.
     */
    exibirTodosInicio() {
        let no = this.inicio;

        console.log("\nLISTA ATUALIZADA INICIO-FINAL");
        while (no !== null) {
            const anteriorValor = no.anterior ? no.anterior.valor : 'null';
            const proximoValor = no.proximo ? no.proximo.valor : 'null';

            console.log(`Anterior: ${anteriorValor} | Valor: ${no.valor} | Pr√≥ximo: ${proximoValor}`);
            no = no.proximo;
        }
    }
    /**
     * @description
     * lista os elementos do √∫ltimo ao primeiro
     */
    exibirTodosFinal() {
        let no = this.final;

        console.log("\nLISTA ATUALIZADA FINAL-INICIO");
        while (no !== null) {
            const anteriorValor = no.anterior ? no.anterior.valor : 'null';
            const proximoValor = no.proximo ? no.proximo.valor : 'null';

            console.log(`Pr√≥ximo: ${proximoValor} | Valor: ${no.valor} | Anterior: ${anteriorValor}`);
            no = no.anterior;
        }
    }
}

module.exports = ListaDuplamenteEncadeada;
let list = new ListaDuplamenteEncadeada()
//adiciona o novo elemento
list.adicionarInicio(1)
//mostra se o novo elemento  foi adicionado
list.exibirTodosInicio()
list.adicionarInicio(2)
list.exibirTodosInicio()
//apaga o elemento com valor 2 - primeiro da lista
list.removerInicio()
//mostra que o elemento 2 foi apagado
list.exibirTodosInicio()
//pesquisa pelo elemento 1
list.buscarElementos(1)
//adiciona elemento ao final
list.adicionarFinal(3)
//mostra se o elemento foi adicionado ao final
list.exibirTodosFinal()
//remove o elemento com valor 3
list.removerFinal()
//deve constar na lista apenas o elemento com valor 1.
list.exibirTodosFinal()
```

## Teste

```jsx
const ListaDuplamenteEncadeada = require('./Q11.js'); 

describe('ListaDuplamenteEncadeada', () => {
    let lista;

    beforeEach(() => {
        lista = new ListaDuplamenteEncadeada();
    });

    test('deve iniciar vazia', () => {
        expect(lista.inicio).toBeNull();
        expect(lista.final).toBeNull();
        expect(lista.tamanho).toBe(0);
    });

    test('deve adicionar elementos no in√≠cio da lista', () => {
        lista.adicionarInicio(1);
        expect(lista.inicio.valor).toBe(1);
        expect(lista.final.valor).toBe(1);
        expect(lista.tamanho).toBe(1);

        lista.adicionarInicio(2);
        expect(lista.inicio.valor).toBe(2);
        expect(lista.inicio.proximo.valor).toBe(1);
        expect(lista.final.valor).toBe(1);
        expect(lista.tamanho).toBe(2);
    });

    test('deve remover elementos do in√≠cio da lista', () => {
        lista.adicionarInicio(1);
        lista.adicionarInicio(2);
        lista.removerInicio();
        expect(lista.inicio.valor).toBe(1);
        expect(lista.tamanho).toBe(1);

        lista.removerInicio();
        expect(lista.inicio).toBeNull();
        expect(lista.final).toBeNull();
        expect(lista.tamanho).toBe(0);
    });

    test('deve adicionar elementos no final da lista', () => {
        lista.adicionarFinal(1);
        expect(lista.inicio.valor).toBe(1);
        expect(lista.final.valor).toBe(1);
        expect(lista.tamanho).toBe(1);

        lista.adicionarFinal(2);
        expect(lista.final.valor).toBe(2);
        expect(lista.final.anterior.valor).toBe(1);
        expect(lista.inicio.valor).toBe(1);
        expect(lista.tamanho).toBe(2);
    });

    test('deve remover elementos do final da lista', () => {
        lista.adicionarFinal(1);
        lista.adicionarFinal(2);
        lista.removerFinal();
        expect(lista.final.valor).toBe(1);
        expect(lista.tamanho).toBe(1);

        lista.removerFinal();
        expect(lista.inicio).toBeNull();
        expect(lista.final).toBeNull();
        expect(lista.tamanho).toBe(0);
    });

    test('deve buscar elementos na lista', () => {
        lista.adicionarInicio(1);
        lista.adicionarInicio(2);

        expect(lista.buscarElementos(1)).toBe(true);
        expect(lista.buscarElementos(3)).toBe(false);
    });

    test('deve exibir elementos da lista na ordem correta', () => {
        // Aqui voc√™ pode usar um spy para verificar as sa√≠das dos m√©todos exibirTodosInicio e exibirTodosFinal.
        // Note que o Jest n√£o captura a sa√≠da para o console por padr√£o, ent√£o voc√™ pode precisar usar bibliotecas como 'jest-mock' para capturar console.log, se necess√°rio.
        // Para simplificar, aqui apenas vamos garantir que os m√©todos n√£o lancem erros.
        expect(() => lista.exibirTodosInicio()).not.toThrow();
        expect(() => lista.exibirTodosFinal()).not.toThrow();
    });
});
```

# Quest√£o 12

Escreva uma fun√ß√£o que receba dois arrays e retorne um novo array contendo os
elementos comuns aos dois arrays, sem duplicatas.

## Solu√ß√£o

```jsx
class Questao12{
    /**
     * @constructor 
     * Define duas listas que ser√£o comparadas 
     * @param {this.repeticoes = []} this.repeticoes - array que armazenar√° quais valores as listas 1 e 2 possuem em comum
     */
    constructor(){
        this.lista1 = [1,2,3,4,5]
        this.lista2 = [1,2,3,5,6]
        this.repeticoes = []
    }
    /**
     * @description
     * primeiro percorre a primeira lista, capturando o valor do indice atual e em seguida
     * compara o valor deste indice com cada valor da lista 2 percorrendo ela. Ao encontrar 
     * um elemento em comum, verifica se ele j√° est√° incl√≠do na lista de repeti√ß√µes, se n√£o estiver
     * ele √© inserido a lista this.repeti√ß√µes.
     * @returns deve retornar a lista de repeti√ß√µes.
     */
    verificar(){
        for(var i = 0; i < this.lista1.length; i++){

            for(var j = 0; j < this.lista2.length; j++){
                if(this.lista1[i] === this.lista2[j]){
                    if(this.repeticoes.includes(this.lista1[i]) === false){
                        this.repeticoes.push(this.lista1[i])
                    }
                } 

            } 
        }
        console.log("ITENS EM COMUM NAS DUAS LISTAS \n" + this.repeticoes + "\nTotal de itens comuns: " + this.repeticoes.length)
        return this.repeticoes
    }

}
module.exports = Questao12;
let questao = new Questao12();
questao.verificar();
```

## Teste

```jsx
const Questao12 = require('./Q12.js');

test('verifica itens comuns entre duas listas', () => {
    const questao = new Questao12();
    const resultado = questao.verificar();
    expect(resultado).toEqual([1, 2, 3, 5]);
});

test('verifica itens comuns com listas diferentes', () => {
    const questao = new Questao12();
    questao.lista1 = [10, 20, 30];
    questao.lista2 = [30, 40, 50];
    const resultado = questao.verificar();
    expect(resultado).toEqual([30]);
});

test('verifica itens comuns com listas sem itens comuns', () => {
    const questao = new Questao12();
    questao.lista1 = [10, 20, 30];
    questao.lista2 = [40, 50, 60];
    const resultado = questao.verificar();
    expect(resultado).toEqual([]);
});

```

# Quest√£o 13

Escreva uma fun√ß√£o que receba dois arrays e retorne um novo array contendo todos
os elementos dos dois arrays, sem duplicatas.

## Solu√ß√£o

```jsx
/**
 * Mescla dois arrays e remove elementos duplicados.
 *
 * @param {Array} arr1 - O primeiro array a ser mesclado.
 * @param {Array} arr2 - O segundo array a ser mesclado.
 * @returns {Array} Um novo array contendo todos os elementos de arr1 e arr2, sem duplicatas.
 */
function arraysemduplicata(arr1, arr2) {
  // Concatena os dois arrays
  const mergedArray = [...arr1, ...arr2];
  
  // Converte o array resultante em um Set para remover duplicatas e depois volta a um array
  return [...new Set(mergedArray)];
}

// Exemplo de uso:
const array1 = [1, 2, 3, 4];
const array2 = [3, 4, 5, 6];

const result = arraysemduplicata(array1, array2);
console.log(result); // Output: [1, 2, 3, 4, 5, 6]
```

## Teste

```jsx
// mergeArrays.js
function arraysemduplicata(arr1, arr2) {
    const mergedArray = [...arr1, ...arr2];
    return [...new Set(mergedArray)];
  }
  
  module.exports = arraysemduplicata;
  
  // mergeArrays.test.js
  const arraysemduplicata = require('./mergeArrays');
  
  test('arraysemduplicata removes duplicates and merges arrays', () => {
    const array1 = [1, 2, 3, 4];
    const array2 = [3, 4, 5, 6];
    const expected = [1, 2, 3, 4, 5, 6];
  
    expect(mergeAndRemoveDuplicates(array1, array2)).toEqual(expected);
  });
  
  test('arraysemduplicata works with empty arrays', () => {
    const array1 = [];
    const array2 = [];
    const expected = [];
  
    expect(arraysemduplicata(array1, array2)).toEqual(expected);
  });
  
  test('arraysemduplicata handles arrays with no common elements', () => {
    const array1 = [1, 2, 3];
    const array2 = [4, 5, 6];
    const expected = [1, 2, 3, 4, 5, 6];
  
    expect(arraysemduplicata(array1, array2)).toEqual(expected);
  });
  
  test('arraysemduplicata handles arrays with all duplicates', () => {
    const array1 = [1, 1, 1];
    const array2 = [1, 1, 1];
    const expected = [1];
  
    expect(arraysemduplicata(array1, array2)).toEqual(expected);
  });
  
```

# Quest√£o 14

Escreva uma fun√ß√£o que encontre o segundo maior n√∫mero em um array de
n√∫meros.

## Solu√ß√£o

```jsx
/**
 * Encontra o segundo maior n√∫mero em um array de n√∫meros.
 *
 * @param {number[]} arr - O array de n√∫meros.
 * @returns {number} O segundo maior n√∫mero no array.
 * @throws {Error} Se o array tiver menos de dois elementos ou n√£o houver um segundo maior n√∫mero.
 */
function encontrarSegundoMaiorNumero(arr) {
    if (arr.length < 2) {
      throw new Error('Array deve ter pelo menos dois elementos');
    }
  
    let maior = -Infinity;
    let segundoMaior = -Infinity;
  
    for (let num of arr) {
      if (num > maior) {
        segundoMaior = maior;
        maior = num;
      } else if (num > segundoMaior && num !== maior) {
        segundoMaior = num;
      }
    }
  
    if (segundoMaior === -Infinity) {
      throw new Error('N√£o h√° segundo maior n√∫mero no array');
    }
  
    return segundoMaior;
  }
  
  module.exports = encontrarSegundoMaiorNumero;
  
```

## Teste

```jsx
const encontrarSegundoMaiorNumero = require('./encontrarSegundoMaiorNumero');

describe('encontrarSegundoMaiorNumero', () => {
  test('deve encontrar o segundo maior n√∫mero em um array', () => {
    const numeros = [10, 20, 4, 45, 99];
    const resultado = encontrarSegundoMaiorNumero(numeros);
    expect(resultado).toBe(45);
  });

  test('deve lan√ßar um erro se o array tiver menos de dois elementos', () => {
    const numeros = [10];
    expect(() => encontrarSegundoMaiorNumero(numeros)).toThrow('Array deve ter pelo menos dois elementos');
  });

  test('deve lan√ßar um erro se n√£o houver segundo maior n√∫mero', () => {
    const numeros = [10, 10];
    expect(() => encontrarSegundoMaiorNumero(numeros)).toThrow('N√£o h√° segundo maior n√∫mero no array');
  });

  test('deve lidar corretamente com arrays com n√∫meros negativos', () => {
    const numeros = [-10, -20, -4, -45, -99];
    const resultado = encontrarSegundoMaiorNumero(numeros);
    expect(resultado).toBe(-10);
  });

  test('deve lidar corretamente com arrays com n√∫meros repetidos', () => {
    const numeros = [10, 20, 20, 45, 99];
    const resultado = encontrarSegundoMaiorNumero(numeros);
    expect(resultado).toBe(45);
  });
});
```

# Quest√£o 15

Escreva uma fun√ß√£o que receba um array e um n√∫mero alvo, e retorne todos os
pares de elementos do array cuja soma seja igual ao n√∫mero alvo.

## Solu√ß√£o

```jsx
// encontrarPares.js

/**
 * Encontra todos os pares de elementos em um array cuja soma seja igual ao n√∫mero alvo.
 * @param {number[]} array - O array de n√∫meros a ser pesquisado.
 * @param {number} alvo - O n√∫mero alvo cuja soma deve ser igual √† soma dos pares.
 * @returns {number[][]} - Uma matriz contendo todos os pares de elementos cuja soma √© igual ao n√∫mero alvo.
 */
function encontrarPares(array, alvo) {
    const pares = [];
    const vistos = new Set();
  
    for (const num of array) {
      const complemento = alvo - num;
      if (vistos.has(complemento)) {
        pares.push([complemento, num]);
      }
      vistos.add(num);
    }
  
    return pares;
  }
  
  module.exports = encontrarPares;
  
```

## Teste

```jsx
// encontrarPares.test.js

const encontrarPares = require('./encontrarPares');

test('Deve encontrar todos os pares cuja soma √© igual ao n√∫mero alvo', () => {
  expect(encontrarPares([1, 2, 3, 4, 3, 5], 6)).toEqual([
    [4, 2],
    [3, 3]
  ]);
});

test('Deve retornar uma matriz vazia se nenhum par for encontrado', () => {
  expect(encontrarPares([1, 2, 3, 4, 5], 10)).toEqual([]);
});

test('Deve encontrar pares em arrays com n√∫meros negativos', () => {
  expect(encontrarPares([-1, -2, -3, -4, -5], -6)).toEqual([
    [-1, -5],
    [-2, -4]
  ]);
});

test('Deve retornar uma matriz vazia para um array vazio', () => {
  expect(encontrarPares([], 0)).toEqual([]);
});

test('Deve retornar uma matriz vazia se o alvo n√£o for um par poss√≠vel', () => {
  expect(encontrarPares([1, 2, 3, 4, 5], 20)).toEqual([]);
});
```

# Quest√£o 16

Escreva uma fun√ß√£o que encontre o elemento mais frequente em um array.

## Solu√ß√£o

```jsx
class EncontrarElementoMaisFrequente {
    constructor() {
        this.contagem = {};
    }

    contarElemento(array) { 
        this.contagem = {}; 
        for (const elemento of array) {
            const chave = typeof elemento === 'string' ? elemento : String(elemento);
            if (this.contagem[chave]) {
                this.contagem[chave]++;
            } else {
                this.contagem[chave] = 1;
            }
        }
    }

    maisFrequente() {
        if (Object.keys(this.contagem).length === 0) {
            return null;
        }
        let elementoMaisFrequente = null;
        let frequenciaMaxima = 0;

        for (const [elemento, frequencia] of Object.entries(this.contagem)) {
            if (frequencia > frequenciaMaxima) {
                frequenciaMaxima = frequencia;
                elementoMaisFrequente = elemento;
            }
        }
        if (elementoMaisFrequente === "true") return true;
        if (elementoMaisFrequente === "false") return false;
        if (!isNaN(Number(elementoMaisFrequente))) return Number(elementoMaisFrequente);
        return elementoMaisFrequente;
    }
}
module.exports = EncontrarElementoMaisFrequente;
const array1 = [5, 5, 3, 3, 3, 2, 2];
const array2 = [10, 10, 20, 20, 30, 30, 30, 30];
const instancia1 = new EncontrarElementoMaisFrequente();
const instancia2 = new EncontrarElementoMaisFrequente();

instancia1.contarElemento(array1);
console.log(instancia1.maisFrequente()); 

instancia2.contarElemento(array2);
console.log(instancia2.maisFrequente()); 
```

## Teste

```jsx
const EncontrarElementoMaisFrequente = require('./Q7');

describe('EncontrarElementoMaisFrequente', () => {
    let instancia;

    beforeEach(() => {
        instancia = new EncontrarElementoMaisFrequente();
    });

    test('deve encontrar o elemento mais frequente em um array simples', () => {
        const array = [1, 2, 2, 3, 3, 3];
        instancia.contarElemento(array);
        expect(instancia.maisFrequente()).toBe(3);
    });

    test('deve retornar o elemento correto quando h√° um empate', () => {
        const array = [1, 2, 2, 3, 3];
        instancia.contarElemento(array);
        // A l√≥gica pode variar dependendo de como voc√™ deseja lidar com empates. Aqui estamos assumindo que retornamos o primeiro elemento mais frequente.
        expect(instancia.maisFrequente()).toBe(2);
    });

    test('deve retornar null para um array vazio', () => {
        const array = [];
        instancia.contarElemento(array);
        expect(instancia.maisFrequente()).toBeNull();
    });

    test('deve lidar com elementos √∫nicos', () => {
        const array = [1, 2, 3];
        instancia.contarElemento(array);
        expect(instancia.maisFrequente()).toBe(1);
    });

    test('deve lidar com strings como elementos', () => {
        const array = ['a', 'b', 'a', 'c', 'a'];
        instancia.contarElemento(array);
        expect(instancia.maisFrequente()).toBe('a');
    });

    test('deve lidar com n√∫meros negativos', () => {
        const array = [-1, -2, -2, -3, -2];
        instancia.contarElemento(array);
        expect(instancia.maisFrequente()).toBe(-2);
    });

    test('deve lidar com elementos n√£o num√©ricos', () => {
        const array = [true, false, true, false, false];
        instancia.contarElemento(array);
        expect(instancia.maisFrequente()).toBe(false);
    });
});

```